/***********************************************************************/
/*                                                                     */
/*  FILE        :hwsetup.c                                             */
/*  DATE        :Wed, Jun 02, 2019                                     */
/*  DESCRIPTION :Hardware Setup file                                   */
/*  CPU TYPE    :RX71M                                                 */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.53).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/*                                                                     */
/***********************************************************************/
/************************************************************************
*
* Device     : R5F571MLCxFC
*
* File Name  : hwsetup.c
*
* Abstract   : Hardware Setup file.
*
* History    : 1.00  (2010-06-08)  [Hardware Manual Revision : 0.20]
*
* NOTE       : THIS IS A TYPICAL EXAMPLE.
*
*  Copyright (C) 2010 Renesas Electronics Corporation and
*  Renesas Solutions Corp. All rights reserved.
*
************************************************************************/

#include "machine.h"
#include "iodefine.h"
#include "hwsetup.h"
#ifdef __cplusplus
extern "C" {
#endif
extern void HardwareSetup(void);
#ifdef __cplusplus
}
#endif

void IOSetting(void);
void SysClockSetting(void);
void init_GPT1_three_phase_wave(void);
void init_AD12A(void);
//void init_AD10(void);
//void init_Input_Capture(void);

//========== can_bus ==========//
void init_can(void);
void init_can_mailbox(void);
//=============================//

void HardwareSetup(void)
{
	SysClockSetting();
	IOSetting();	
	init_GPT1_three_phase_wave();
	init_AD12A();
//	init_AD10();
	//init_Input_Capture();
	
	//========== can_bus ==========//
//	init_can();
//	init_can_mailbox();	
}

void IOSetting(void)
{	
	// PFSWE Bit Write Disable
	MPC.PWPR.BIT.B0WI = 0;
	  //0: Writing to the PFSWE bit is enabled
	  //1: Writing to the PFSWE bit is disabled
	
	/*Write-Protect Register*/
	// PFS Register Write Enable
	MPC.PWPR.BIT.PFSWE = 1;
	  //0: Writing to the PFS register is disabled
	  //1: Writing to the PFS register is enabled	 	

	/*set LED I/O direction*/
	PORT1.PDR.BIT.B4 = 1;  //power_on
	PORT1.PDR.BIT.B3 = 1;  //hoVDC
	PORT1.PDR.BIT.B2 = 1;  //hoVAC
	PORTC.PDR.BIT.B6 = 1;  //problem
	PORTC.PDR.BIT.B5 = 1;  //Hardware portection
	PORT8.PDR.BIT.B2 = 1;  //LEDFault1
	PORT8.PDR.BIT.B1 = 1;  //LEDFault2
	PORT8.PDR.BIT.B0 = 1;  //LEDFault3
	PORTC.PDR.BIT.B4 = 1;  //LEDFault4
	PORTC.PDR.BIT.B3 = 1;  //LEDFault5
	PORT7.PDR.BIT.B7 = 1;  //LED1
	PORT7.PDR.BIT.B6 = 1;  //LED2
	PORTC.PDR.BIT.B2 = 1;  //LED3
	PORT7.PDR.BIT.B5 = 1;  //LED4
	PORT7.PDR.BIT.B4 = 1;  //LED5
	
	/*clear LED I/O data*/
	PORT1.PODR.BIT.B4 = 0;  //power_on
	PORT1.PODR.BIT.B3 = 0;  //spare1
	PORT1.PODR.BIT.B2 = 0;  //spare2
	PORTC.PODR.BIT.B6 = 0;  //spare3
	PORTC.PODR.BIT.B5 = 0;  //Hardware_portection
	PORT8.PODR.BIT.B2 = 0;  //LEDFault1
	PORT8.PODR.BIT.B1 = 0;  //LEDFault2
	PORT8.PODR.BIT.B0 = 0;  //LEDFault3
	PORTC.PODR.BIT.B4 = 0;  //LEDFault4
	PORTC.PODR.BIT.B3 = 0;  //LEDFault5
	PORT7.PODR.BIT.B7 = 0;  //LED1
	PORT7.PODR.BIT.B6 = 0;  //LED2
	PORTC.PODR.BIT.B2 = 0;  //LED3
	PORT7.PODR.BIT.B5 = 0;  //LED4
	PORT7.PODR.BIT.B4 = 0;  //LED5

	/*set Relay & Buffer_in I/O direction*/
	PORT2.PDR.BIT.B5 = 1;  //Relay
	PORT2.PDR.BIT.B4 = 1;  //Buffer_in1
	PORT2.PDR.BIT.B0 = 1;  //Buffer_in2
	PORT5.PDR.BIT.B6 = 1;  //Buffer_in3
	PORT5.PDR.BIT.B3 = 1;  //Buffer_in4
	PORT5.PDR.BIT.B1 = 1;  //Buffer_in5
	PORTB.PDR.BIT.B6 = 1;  //Buffer_in6
	PORTB.PDR.BIT.B5 = 1;  //Buffer_in7

	/*clear Relay & Buffer_in I/O data*/
	PORT2.PODR.BIT.B5 = 0;  //Relay
	PORT2.PODR.BIT.B4 = 0;  //Buffer_in1
	PORT2.PODR.BIT.B0 = 0;  //Buffer_in2
	PORT5.PODR.BIT.B6 = 0;  //Buffer_in3
	PORT5.PODR.BIT.B3 = 0;  //Buffer_in4
	PORT5.PODR.BIT.B1 = 0;  //Buffer_in5
	PORTB.PODR.BIT.B6 = 0;  //Buffer_in6
	PORTB.PODR.BIT.B5 = 0;  //Buffer_in7

	/*set PWM_B series I/O direction*/
	PORT2.PDR.BIT.B3 = 1;  //PWMRH_DIR
	PORT2.PDR.BIT.B2 = 1;  //PWMSH_DIR
	PORT2.PDR.BIT.B1 = 1;  //PWMTH_DIR
	PORT1.PDR.BIT.B7 = 1;  //PWMRL_DIR
	PORT8.PDR.BIT.B7 = 1;  //PWMSL_DIR
	PORT8.PDR.BIT.B6 = 1;  //PWMTL_DIR
	PORTE.PDR.BIT.B7 = 1;  //PWMNH_DIR
	PORTE.PDR.BIT.B6 = 1;  //PWMNL_DIR

	/*clear PWM_B series I/O data*/
	PORT2.PODR.BIT.B3 = 0;  //PWMRH_IO
	PORT2.PODR.BIT.B2 = 0;  //PWMSH_IO
	PORT2.PODR.BIT.B1 = 0;  //PWMTH_IO
	PORT1.PODR.BIT.B7 = 0;  //PWMRL_IO
	PORT8.PODR.BIT.B7 = 0;  //PWMSL_IO
	PORT8.PODR.BIT.B6 = 0;  //PWMTL_IO
	PORTE.PODR.BIT.B7 = 0;  //PWMNH_IO
	PORTE.PODR.BIT.B6 = 0;  //PWMNL_IO

	/*set PWM_B series GPT function*/
	PORT2.PMR.BIT.B3 = 1;  //PWMRH_PMR
	PORT2.PMR.BIT.B2 = 1;  //PWMSH_PMR
	PORT2.PMR.BIT.B1 = 1;  //PWMTH_PMR
	PORT1.PMR.BIT.B7 = 1;  //PWMRL_PMR
	PORT8.PMR.BIT.B7 = 1;  //PWMSL_PMR
	PORT8.PMR.BIT.B6 = 1;  //PWMTL_PMR
	PORTE.PMR.BIT.B7 = 1;  //PWMNH_PMR
	PORTE.PMR.BIT.B6 = 1;  //PWMNL_PMR

	/*select PWM_B series pins GPT function*/
	MPC.P23PFS.BIT.PSEL = 30;  //PWMRH_PFS
	MPC.P22PFS.BIT.PSEL = 30;  //PWMSH_PFS
	MPC.P21PFS.BIT.PSEL = 30;  //PWMTH_PFS
	MPC.P17PFS.BIT.PSEL = 30;  //PWMRL_PFS
	MPC.P87PFS.BIT.PSEL = 30;  //PWMSL_PFS
	MPC.P86PFS.BIT.PSEL = 30;  //PWMTL_PFS
	MPC.PE7PFS.BIT.PSEL = 30;  //PWMNH_PFS
	MPC.PE6PFS.BIT.PSEL = 30;  //PWMNL_PFS
	

	/*select AD pins ASEL function*/
	//S12AD 
	MPC.P40PFS.BIT.ASEL = 1;  //IiR_fbn   AN000
	MPC.P41PFS.BIT.ASEL = 1;  //IiS_fbn   AN001
	MPC.P42PFS.BIT.ASEL = 1;  //IiT_fbn   AN002
	MPC.P43PFS.BIT.ASEL = 1;  //IDC_fbn   AN003
	MPC.P44PFS.BIT.ASEL = 1;  //VPR_fbn   AN004
	MPC.P45PFS.BIT.ASEL = 1;  //VPS_fbn   AN005
	MPC.P46PFS.BIT.ASEL = 1;  //VPT_fbn   AN006
	MPC.P47PFS.BIT.ASEL = 1;  //FVDC_fbn  AN007 //01-Nov-2019 22:16:19
	//S12AD1 
	MPC.PE2PFS.BIT.ASEL = 1;  //IgR_fbn   AN100
	MPC.PE3PFS.BIT.ASEL = 1;  //IgS_fbn   AN101
	MPC.PE4PFS.BIT.ASEL = 1;  //IgT_fbn   AN102
	MPC.PD6PFS.BIT.ASEL = 1;  //ILDR_fbn -> temp R AN106
	MPC.PD7PFS.BIT.ASEL = 1;  //ILDS_fbn -> temp S AN107
	MPC.PD0PFS.BIT.ASEL = 1;  //ILDT_fbn -> temp T AN108
	MPC.PD1PFS.BIT.ASEL = 1;  //VCR_fbn   AN109
	MPC.PD2PFS.BIT.ASEL = 1;  //VCS_fbn   AN110
	MPC.PD3PFS.BIT.ASEL = 1;  //VCT_fbn   AN111
	MPC.PD4PFS.BIT.ASEL = 1;  //VGCRN_fbn AN112
	MPC.PD5PFS.BIT.ASEL = 1;  //VGCSN_fbn AN113
	MPC.P90PFS.BIT.ASEL = 1;  //VGCTN_fbn AN114
	MPC.P91PFS.BIT.ASEL = 1;  //HVDC_fbn  AN115 //01-Nov-2019 22:16:19
	
}

void SysClockSetting(void){
	/*  Enables writing to the registers related to the clock generation circuit */ 
	SYSTEM.PRCR.WORD= 0x0A503;
	
	//volatile unsigned long memorywaitcycle;
	
	/* Set main clock control registers */ 
	// Main Clock Oscillator Forced Oscillation
	SYSTEM.MOFCR.BIT.MOFXIN = 0;
	  //0: Oscillator is not controlled by this bit.
	  //1: The main clock oscillator is forcedly oscillated.
	  	
	//Main Clock Oscillator Driving Ability 2 Switching
	SYSTEM.MOFCR.BIT.MODRV2 = 2;
	  // 0 0: 20.1 to 24 MHz
	  // 0 1: 16.1 to 20 MHz
	  // 1 0: 8.1 to 16 MHz
	  // 1 1: 8 MHz
	
	//Main Clock Oscillator Switching 
	SYSTEM.MOFCR.BIT.MOSEL = 0;
	  //0: Resonator
	  //1: External clock input
	

	// Set Main Clock Oscillator Wait Control Register
	SYSTEM.MOSCWTCR.BIT.MSTS = 0x5C;

	/* Set main clock operation*/ 
	// Main Clock Oscillator Stop 
	SYSTEM.MOSCCR.BIT.MOSTP = 0;
	  //0: Main clock oscillator is operating.
	  //1: Main clock oscillator is stopped.	  
	
	
	/* Wait for main clock oscillator wait counter overflow */
	while(1 != SYSTEM.OSCOVFSR.BIT.MOOVF);

	/* Set system clock */
	//PCLKA->GPT, PCLKB->peripheral, PCLKC->ADunit0, PCLKD->ADunit1
	//ICLK: 240 MHz (max) PCLKA: 120 MHz (max) PCLKB: 60 MHz (max) PCLKC: 60 MHz (max) PCLKD: 60 MHz (max)
	//FCLK: 60 MHz BCLK: 60 MHz UCLK: 48 MHz (max)

	//System Clock Control Register
	//Peripheral Module Clock Select 
	SYSTEM.SCKCR.BIT.PCKD = 2;  //0000:*1/1   //0110:*1/64
	SYSTEM.SCKCR.BIT.PCKC = 2;  //0001:*1/2
	SYSTEM.SCKCR.BIT.PCKB = 2;  //0010:*1/4
	SYSTEM.SCKCR.BIT.PCKA = 1;  //0011:*1/8
	SYSTEM.SCKCR.BIT.BCK = 2;   //0100:*1/16
	SYSTEM.SCKCR.BIT.FCK = 2;   //0101:*1/32
                                                   
	//Setting System Clock Select	 	
	SYSTEM.SCKCR.BIT.ICK = 0;
	//0000:*1/1  //0100:*1/16
	//0001:*1/2  //0101:*1/32
	//0010:*1/4  //0110:*1/64
	//0011:*1/8
	//Do not set a frequency lower than the system clock(ICLK)
		
	/* Set PLL circuit */
	//PLL Input Frequency Division Ratio Select
	SYSTEM.PLLCR.BIT.PLIDIV = 0;
	  //00:*1
	  //01:*1/2
	  //10:*1/3
	  
	// PLL Clock Source Select
	SYSTEM.PLLCR.BIT.PLLSRCSEL = 0;
	  //0: Main clock oscillator
	  //1: HOCO

	//Frequency Multiplication Factor Select
	SYSTEM.PLLCR.BIT.STC = 0x27;
	  // 0 1 0 0 1 1:*10.0		1 0 0 0 0 1:*17.0		1 0 1 1 1 1:*24.0
	  // 0 1 0 1 0 0:*10.5		1 0 0 0 1 0:*17.5		1 1 0 0 0 0:*24.5
	  // 0 1 0 1 0 1:*11.0		1 0 0 0 1 1:*18.0		1 1 0 0 0 1:*25.0
	  // 0 1 0 1 1 0:*11.5		1 0 0 1 0 0:*18.5		1 1 0 0 1 0:*25.5
	  // 0 1 0 1 1 1:*12.0		1 0 0 1 0 1:*19.0		1 1 0 0 1 1:*26.0
	  // 0 1 1 0 0 0:*12.5		1 0 0 1 1 0:*19.5		1 1 0 1 0 0:*26.5
	  // 0 1 1 0 0 1:*13.0		1 0 0 1 1 1:*20.0		1 1 0 1 0 1:*27.0
	  // 0 1 1 0 1 0:*13.5		1 0 1 0 0 0:*20.5		1 1 0 1 1 0:*27.5
	  // 0 1 1 0 1 1:*14.0		1 0 1 0 0 1:*21.0		1 1 0 1 1 1:*28.0
	  // 0 1 1 1 0 0:*14.5		1 0 1 0 1 0:*21.5		1 1 1 0 0 0:*28.5
	  // 0 1 1 1 0 1:*15.0		1 0 1 0 1 1:*22.0		1 1 1 0 0 1:*29.0
	  // 0 1 1 1 1 0:*15.5		1 0 1 1 0 0:*22.5		1 1 1 0 1 0:*29.5
	  // 0 1 1 1 1 1:*16.0		1 0 1 1 0 1:*23.0		1 1 1 0 1 1:*30.0
	  // 1 0 0 0 0 0:*16.5		1 0 1 1 1 0:*23.5

	// PLL Stop Control 
	SYSTEM.PLLCR2.BIT.PLLEN = 0;
	  //0: PLL is operating.
	  //1: PLL is stopped.	
	
	/* Wait for PLL wait counter overflow */
	while(1 != SYSTEM.OSCOVFSR.BIT.PLOVF);								

	/* Stop sub-clock */
	RTC.RCR3.BIT.RTCEN = 0;
	  //0: Sub-clock oscillator is stopped.
	  //1: Sub-clock oscillator is operating.  	
	
	/* Wait for the register modification to complete */    
	while(0 != RTC.RCR3.BIT.RTCEN);

	/* Stop sub-clock */
	SYSTEM.SOSCCR.BIT.SOSTP = 1;
	  //0: Sub-clock oscillator is operating.
	  //1: Sub-clock oscillator is stopped.
	
	/* Wait for the register modification to complete */
	while(1 != SYSTEM.SOSCCR.BIT.SOSTP);	

	/* Wait for sub-clock oscillation stopping */
	while(0 != SYSTEM.OSCOVFSR.BIT.SOOVF);

	/* Set UCLK */
	SYSTEM.SCKCR2.BIT.UCK=4;
	  //0 0 0 1: x 1/2
	  //0 0 1 0: x 1/3
	  //0 0 1 1: x 1/4
	  //0 1 0 0: x 1/5

	/* Set BCLK */
	SYSTEM.SCKCR.BIT.PSTOP1 = 1;
	  //0: BCLK pin output is enabled.
	  //1: BCLK pin output is disabled. (Fixed high)

	/* Set SDCLK */
	SYSTEM.SCKCR.BIT.PSTOP0 = 1;
	  //0: SDCLK pin output is enabled.
	  //1: SDCLK pin output is disabled. (Fixed high)
	  
	/* Set clock source */
	SYSTEM.SCKCR3.BIT.CKSEL = 4;	
	  // 0 0 0: LOCO
	  // 0 0 1: HOCO
	  // 0 1 0: Main clock oscillator
	  // 0 1 1: Sub-clock oscillator
	  // 1 0 0: PLL circuit
	
	/* Set memory wait cycle setting register */
	SYSTEM.MEMWAIT.BIT.MEMWAIT = 1;
	//memorywaitcycle = SYSTEM.MEMWAIT.LONG;

	/* Set LOCO */
	SYSTEM.LOCOCR.BIT.LCSTP = 0;
	//SYSTEM.HOCOCR.BIT.HCSTP = 0;	

}

void init_GPT1_three_phase_wave(void){
	/* Disable standby control (open clock to GPT) */
	MSTP(GPT) = 0;

	/* Eable GPT control registers write protect */
	GPT.GTWP.BIT.WP0 = 0;
	GPT.GTWP.BIT.WP1 = 0;
	GPT.GTWP.BIT.WP2 = 0;
	GPT.GTWP.BIT.WP3 = 0;

	/*Buffer operation is enabled*/
	GPT.GTBDR.WORD = 0x0000;
	
	/* Setting count operation */
	GPT.GTSTR.WORD = 0x0000;
	  //0: Count operation is stopped
	  //1: Count operation is started

	/*General PWM Timer Hardware Source Start/Stop Control */
	//Hardware Source Count start
	GPT.GTHSCR.BIT.CSHW0 = 0;  // 00: Count operation is not started by a hardware source.
	GPT.GTHSCR.BIT.CSHW1 = 0;  // 01: Count operation is started at the rising edge of a hardware source.
	GPT.GTHSCR.BIT.CSHW2 = 0;  // 10: Count operation is started at the falling edge of a hardware source.
	GPT.GTHSCR.BIT.CSHW3 = 0;  // 11: Count operation is started at both rising and falling edges of a hardware source.
	//Hardware Source Count Stop
	GPT.GTHSCR.BIT.CPHW0 = 0;  // 00: Count operation is not stopped by a hardware source.
	GPT.GTHSCR.BIT.CPHW1 = 0;  // 01: Count operation is stopped at the rising edge of a hardware source.
	GPT.GTHSCR.BIT.CPHW2 = 0;  // 10: Count operation is stopped at the falling edge of a hardware source.
	GPT.GTHSCR.BIT.CPHW3 = 0;  // 11: Count operation is stopped at both rising and falling edges of a hardware source.

	/*General PWM Timer Hardware Source Clear Control */
	//Hardware Source Counter Clear
	GPT.GTHCCR.BIT.CCHW0 = 0;  // 00: Counter is not cleared by a hardware source.
	GPT.GTHCCR.BIT.CCHW1 = 0;  // 01: Counter is cleared at the rising edge of a hardware source.
	GPT.GTHCCR.BIT.CCHW2 = 0;  // 10: Counter is cleared at the falling edge of a hardware source.
	GPT.GTHCCR.BIT.CCHW3 = 0;  // 11: Counter is cleared at both rising and falling edges of a hardware source.

	/*General PWM Timer Hardware Start Source Select */
	GPT.GTHSSR.BIT.CSHSL0 = 10;  // 1000: GTIOC3A pin input // 1100: GTETRG pin input
	GPT.GTHSSR.BIT.CSHSL1 = 10;  // 1001: GTIOC3B pin input
	GPT.GTHSSR.BIT.CSHSL2 = 10;  // 1010: GTIOC3A internal output (output compare)
	GPT.GTHSSR.BIT.CSHSL3 = 10;  // 1011: GTIOC3B internal output (output compare)

	/* General PWM Timer Hardware Stop/Clear Source Select */
	GPT.GTHPSR.BIT.CSHPL0 = 10;  // 1000: GTIOC3A pin input // 1100: GTETRG pin input
	GPT.GTHPSR.BIT.CSHPL1 = 10;  // 1001: GTIOC3B pin input
	GPT.GTHPSR.BIT.CSHPL2 = 10;  // 1010: GTIOC3A internal output (output compare)
	GPT.GTHPSR.BIT.CSHPL3 = 10;  // 1011: GTIOC3B internal output (output compare)

	/* General PWM Timer Sync Register */
	GPT.GTSYNC.BIT.SYNC0 = 3;
	  // 00:ynchronized clear is not performed
	  // 01: GPT0.GTCNT is synchronously cleared by a GPT1 clearing source
	  // 10: GPT0.GTCNT is synchronously cleared by a GPT2 clearing source
	  // 11: GPT0.GTCNT is synchronously cleared by a GPT3 clearing source
	GPT.GTSYNC.BIT.SYNC1 = 3;
	  // 00: GPT1.GTCNT is synchronously cleared by a GPT0 clearing source
	  // 01: synchronized clear is not performed
	  // 10: GPT1.GTCNT is synchronously cleared by a GPT2 clearing source
	  // 11: GPT1.GTCNT is synchronously cleared by a GPT3 clearing source
	GPT.GTSYNC.BIT.SYNC2 = 3;
	  // 00: GPT2.GTCNT is synchronously cleared by a GPT0 clearing source
	  // 01: GPT2.GTCNT is synchronously cleared by a GPT1 clearing source
	  // 10: synchronized clear is not performed
	  // 11: GPT2.GTCNT is synchronously cleared by a GPT3 clearing source
	GPT.GTSYNC.BIT.SYNC3 = 3;
	  // 00: GPT3.GTCNT is synchronously cleared by a GPT0 clearing source
	  // 01: GPT3.GTCNT is synchronously cleared by a GPT1 clearing source
	  // 10: GPT3.GTCNT is synchronously cleared by a GPT2 clearing source  
	  // 11: synchronized clear is not performed	

	/*========GPT0=============*/
	// GPT0 mode select
	GPT0.GTCR.BIT.MD = 5;
	  // 000: Saw-wave PWM mode (single buffer or double buffer possible)
	  // 001: Saw-wave one-shot pulse mode (fixed buffer operation)
	  // 010: Setting prohibited
	  // 011: Setting prohibited
	  // 100: Triangle-wave PWM mode 1 (16-bit transfer at crest) (single buffer or double buffer possible)
	  // 101: Triangle-wave PWM mode 2 (16-bit transfer at crest and trough) (single buffer or double buffer possible)
	  // 110: Triangle-wave PWM mode 3 (32-bit transfer at trough) fixed buffer operation)
	  // 111: Setting prohibited	
	// Timer Prescaler Select
	GPT0.GTCR.BIT.TPCS = 0;
	  // 00: PCLKA
	  // 01: PCLKA/2
	  // 10: PCLKA/4
	  // 11: PCLKA/8
	GPT0.GTCR.BIT.CCLR = 3;
	  // 00: None of the following clearing sources is specified.
	  // 01: Cleared by GTCCRA input capture
	  // 10: Cleared by GTCCRB input capture
	  // 11: Cleared by counter clearing in another channel performing synchronous clearing/synchronous operation

	/*Count	Direction Setting*/
	GPT0.GTUDC.BIT.UD = 1;
	  // 0: GTCNT counts down.
	  // 1: GTCNT counts up.
	GPT0.GTUDC.BIT.UDF = 0;
	  // 0: Not forcibly set
	  // 1: Forcibly set

	/*General PWM Timer I/O Control Register (GTIOR)*/
	GPT0.GTIOR.BIT.GTIOA = 0x07;  //PWMRH //010 //0x000111: Compare match(b5), Initial output is low(b4), Low output at cycle end(b3, b2), Toggle output at GPTn.GTCCRA compare match
	GPT0.GTIOR.BIT.GTIOB = 0x1B;  //PWMRL //101 //0x011011: Compare match(b5), Initial output is high(b4), High output at cycle end(b3, b2), Toggle output at GPTn.GTCCRA compare match

	/*General PWM Timer Buffer Enable Register (GTBER)*/
	GPT0.GTBER.BIT.CCRA = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTCCRA <=> GTCCRC)
	  // 1x: Double buffer operation (GTCCRA <=> GTCCRC <=> GTCCRD)
	GPT0.GTBER.BIT.CCRB = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTCCRB <=> GTCCRE)
	  // 1x: Double buffer operation (GTCCRB <=> GTCCRE <=> GTCCRF)
	GPT0.GTBER.BIT.PR = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTPBR <=> GTPR)
	  // 1x: Double buffer operation (GTPDBR <=> GTPBR <=> GTPR)

	/*General PWM Timer Cycle Setting Register (GTPR)*/
	GPT0.GTPR = 3030;   //19.8 kHz
	GPT0.GTPBR =3030; //19.8 kHz

	/*General PWM timer Compare Capture Register m (GTCCRm)*/
	GPT0.GTCCRA = 1515;
	GPT0.GTCCRB = 1500;

	/*General PWM Timer Output Negate Cintrol Register(GTONCR)*/
	// GRIOCnA Pin Negate Control Enable
	GPT0.GTONCR.BIT.NEA = 0;  // 0: Negate is disabled
	GPT0.GTONCR.BIT.NEB = 0;  // 1: Negate is enabled
	GPT0.GTONCR.BIT.NVA = 0;  // 0: No pin output
	GPT0.GTONCR.BIT.NVB = 0;  // 1: Pin output
	// GRIOCnA Pin Output Enable
	GPT0.GTONCR.BIT.OAE = 0;  // 0: Output is disabled
	GPT0.GTONCR.BIT.OBE = 0;  // 1: Output is enabled

	/*set A/D buffer register*/
	GPT0.GTBER.BIT.ADTTA = 1;
	  // Triangle waves
	  // 00: No transfer
	  // 01: Transfer at crest
	  // 10: Transfer at trough
	  // 11: Transfer at both crest and trough
	GPT0.GTBER.BIT.ADTDA = 0;
	  // 0: Single buffer operation(GTADTBRA -> GTADTRA)
	  // 1: Double buffer operation(GTADTDBRA -> GTADTBRA -> GTADTRA)
	GPT0.GTBER.BIT.ADTTB = 1;
	  // Triangle waves
	  // 00: No transfer
	  // 01: Transfer at crest
	  // 10: Transfer at trough
	  // 11: Transfer at both crest and trough
	GPT0.GTBER.BIT.ADTDB = 0;
	  // 0: Single buffer operation(GTADTBRB -> GTADTRB)
	  // 1: Double buffer operation(GTADTDBRB -> GTADTBRB -> GTADTRB)

	/*Setting A/D converter Start Request Enable*/
	GPT0.GTINTAD.BIT.ADTRAUEN = 0;
	GPT0.GTINTAD.BIT.ADTRADEN = 1;
	GPT0.GTINTAD.BIT.ADTRBUEN = 0;
	GPT0.GTINTAD.BIT.ADTRBDEN = 0;

	/*Setting A/D Trigger timer*/
	//GPT0.GTADTRA = 600;   // sams as GPT3.GTCCRD (Cycle_sign Interrupt) desigened by sampling frequency
	//GPT0.GTADTBRA = 600;
	//GPT0.GTADTRB = 100;   // if we choose group scan mode we need to set GTADTRB 
	//GPT0.GTADTBRB = 100;

	/*set carrier crest*/
	GPT0.GTINTAD.BIT.GTINTPR = 0;
	  //00:Interrupt request is disabled.
	  //01:In saw-wave mode, interrupt requests are enabled at overflows.
	  //   In triangle-wave mode, interrupt requests are enabled at crests.
	  //10:In saw-wave mode, interrupt requests are enabled at underflows.
	  //   In triangle-wave mode, interrupt requests are enabled at troughs.
	  //11:In saw-wave mode, interrupt requests are enabled at both overflows and underflows. 
	  //   In triangle-wave mode, interrupt requests are enabled at both crests and troughs.

	/*GPT3.GTITC.BIT.IVTC = 0;	  //Skipping not performed
	IEN(GPT3,GTCIV3)= 0;//ERROR
	GPT3.GTST.BIT.TCFPU=0;
	IPR(GPT3,GTCIV3) = 14;  
	IEN(GPT3,GTCIV3)= 1;*/

	/*========GPT1=============*/
	// GPT1 mode select
	GPT1.GTCR.BIT.MD = 5;
	  // 000: Saw-wave PWM mode (single buffer or double buffer possible)
	  // 001: Saw-wave one-shot pulse mode (fixed buffer operation)
	  // 010: Setting prohibited
	  // 011: Setting prohibited
	  // 100: Triangle-wave PWM mode 1 (16-bit transfer at crest) (single buffer or double buffer possible)
	  // 101: Triangle-wave PWM mode 2 (16-bit transfer at crest and trough) (single buffer or double buffer possible)
	  // 110: Triangle-wave PWM mode 3 (32-bit transfer at trough) fixed buffer operation)
	  // 111: Setting prohibited	
	// Timer Prescaler Select
	GPT1.GTCR.BIT.TPCS = 0;
	  // 00: PCLKA
	  // 01: PCLKA/2
	  // 10: PCLKA/4
	  // 11: PCLKA/8
	GPT1.GTCR.BIT.CCLR = 3;
	  // 00: None of the following clearing sources is specified.
	  // 01: Cleared by GTCCRA input capture
	  // 10: Cleared by GTCCRB input capture
	  // 11: Cleared by counter clearing in another channel performing synchronous clearing/synchronous operation

	/*Count	Direction Setting*/
	GPT1.GTUDC.BIT.UD = 1;
	  // 0: GTCNT counts down.
	  // 1: GTCNT counts up.
	GPT1.GTUDC.BIT.UDF = 0;
	  // 0: Not forcibly set
	  // 1: Forcibly set

	/*General PWM Timer I/O Control Register (GTIOR)*/
	GPT1.GTIOR.BIT.GTIOA = 0x07;  //PWMSH //010 //0x000111: Compare match(b5), Initial output is low(b4), Low output at cycle end(b3, b2), Toggle output at GPTn.GTCCRA compare match
	GPT1.GTIOR.BIT.GTIOB = 0x1B;  //PWMSL //101 //0x011011: Compare match(b5), Initial output is high(b4), High output at cycle end(b3, b2), Toggle output at GPTn.GTCCRA compare match

	/*General PWM Timer Buffer Enable Register (GTBER)*/
	GPT1.GTBER.BIT.CCRA = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTCCRA <=> GTCCRC)
	  // 1x: Double buffer operation (GTCCRA <=> GTCCRC <=> GTCCRD)
	GPT1.GTBER.BIT.CCRB = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTCCRB <=> GTCCRE)
	  // 1x: Double buffer operation (GTCCRB <=> GTCCRE <=> GTCCRF)
	GPT1.GTBER.BIT.PR = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTPBR <=> GTPR)
	  // 1x: Double buffer operation (GTPDBR <=> GTPBR <=> GTPR)

	/*General PWM Timer Cycle Setting Register (GTPR)*/
	GPT1.GTPR = 3030;   //19.8 kHz
	GPT1.GTPBR = 3030; //19.8 kHz

	/*General PWM timer Compare Capture Register m (GTCCRm)*/
	GPT1.GTCCRA = 1515;
	GPT1.GTCCRB = 1500;

	/*General PWM Timer Output Negate Cintrol Register(GTONCR)*/
	// GRIOCnA Pin Negate Control Enable
	GPT1.GTONCR.BIT.NEA = 0;  // 0: Negate is disabled
	GPT1.GTONCR.BIT.NEB = 0;  // 1: Negate is enabled
	GPT1.GTONCR.BIT.NVA = 0;  // 0: No pin output
	GPT1.GTONCR.BIT.NVB = 0;  // 1: Pin output
	// GRIOCnA Pin Output Enable
	GPT1.GTONCR.BIT.OAE = 0;  // 0: Output is disabled
	GPT1.GTONCR.BIT.OBE = 0;  // 1: Output is enabled

	/*========GPT2=============*/
	// GPT2 mode select
	GPT2.GTCR.BIT.MD = 5;
	  // 000: Saw-wave PWM mode (single buffer or double buffer possible)
	  // 001: Saw-wave one-shot pulse mode (fixed buffer operation)
	  // 010: Setting prohibited
	  // 011: Setting prohibited
	  // 100: Triangle-wave PWM mode 1 (16-bit transfer at crest) (single buffer or double buffer possible)
	  // 101: Triangle-wave PWM mode 2 (16-bit transfer at crest and trough) (single buffer or double buffer possible)
	  // 110: Triangle-wave PWM mode 3 (32-bit transfer at trough) fixed buffer operation)
	  // 111: Setting prohibited	
	// Timer Prescaler Select
	GPT2.GTCR.BIT.TPCS = 0;
	  // 00: PCLKA
	  // 01: PCLKA/2
	  // 10: PCLKA/4
	  // 11: PCLKA/8
	GPT2.GTCR.BIT.CCLR = 3;
	  // 00: None of the following clearing sources is specified.
	  // 01: Cleared by GTCCRA input capture
	  // 10: Cleared by GTCCRB input capture
	  // 11: Cleared by counter clearing in another channel performing synchronous clearing/synchronous operation

	/*Count	Direction Setting*/
	GPT2.GTUDC.BIT.UD = 1;
	  // 0: GTCNT counts down.
	  // 1: GTCNT counts up.
	GPT2.GTUDC.BIT.UDF = 0;
	  // 0: Not forcibly set
	  // 1: Forcibly set

	/*General PWM Timer I/O Control Register (GTIOR)*/
	GPT2.GTIOR.BIT.GTIOA = 0x07;  //PWMTH //010 //0x000111: Compare match(b5), Initial output is low(b4), Low output at cycle end(b3, b2), Toggle output at GPTn.GTCCRA compare match
	GPT2.GTIOR.BIT.GTIOB = 0x1B;  //PWMTL //101 //0x011011: Compare match(b5), Initial output is high(b4), High output at cycle end(b3, b2), Toggle output at GPTn.GTCCRA compare match

	/*General PWM Timer Buffer Enable Register (GTBER)*/
	GPT2.GTBER.BIT.CCRA = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTCCRA <=> GTCCRC)
	  // 1x: Double buffer operation (GTCCRA <=> GTCCRC <=> GTCCRD)
	GPT2.GTBER.BIT.CCRB = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTCCRB <=> GTCCRE)
	  // 1x: Double buffer operation (GTCCRB <=> GTCCRE <=> GTCCRF)
	GPT2.GTBER.BIT.PR = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTPBR <=> GTPR)
	  // 1x: Double buffer operation (GTPDBR <=> GTPBR <=> GTPR)

	/*General PWM Timer Cycle Setting Register (GTPR)*/
	GPT2.GTPR = 3030;   //19.8 kHz
	GPT2.GTPBR = 3030; //19.8 kHz

	/*General PWM timer Compare Capture Register m (GTCCRm)*/
	//GPT2.GTCCRA = 1515;
	//GPT2.GTCCRB = 1500;

	/*General PWM Timer Output Negate Cintrol Register(GTONCR)*/
	// GRIOCnA Pin Negate Control Enable
	GPT2.GTONCR.BIT.NEA = 0;  // 0: Negate is disabled
	GPT2.GTONCR.BIT.NEB = 0;  // 1: Negate is enabled
	GPT2.GTONCR.BIT.NVA = 0;  // 0: No pin output
	GPT2.GTONCR.BIT.NVB = 0;  // 1: Pin output
	// GRIOCnA Pin Output Enable
	GPT2.GTONCR.BIT.OAE = 0;  // 0: Output is disabled
	GPT2.GTONCR.BIT.OBE = 0;  // 1: Output is enabled

	/*========GPT3=============*/
	// GPT3 mode select
	GPT3.GTCR.BIT.MD = 5;
	  // 000: Saw-wave PWM mode (single buffer or double buffer possible)
	  // 001: Saw-wave one-shot pulse mode (fixed buffer operation)
	  // 010: Setting prohibited
	  // 011: Setting prohibited
	  // 100: Triangle-wave PWM mode 1 (16-bit transfer at crest) (single buffer or double buffer possible)
	  // 101: Triangle-wave PWM mode 2 (16-bit transfer at crest and trough) (single buffer or double buffer possible)
	  // 110: Triangle-wave PWM mode 3 (32-bit transfer at trough) fixed buffer operation)
	  // 111: Setting prohibited	
	// Timer Prescaler Select
	GPT3.GTCR.BIT.TPCS = 0;
	  // 00: PCLKA
	  // 01: PCLKA/2
	  // 10: PCLKA/4
	  // 11: PCLKA/8
	GPT3.GTCR.BIT.CCLR = 0;
	  // 00: None of the following clearing sources is specified.
	  // 01: Cleared by GTCCRA input capture
	  // 10: Cleared by GTCCRB input capture
	  // 11: Cleared by counter clearing in another channel performing synchronous clearing/synchronous operation

	/*Count	Direction Setting*/
	GPT3.GTUDC.BIT.UD = 1;
	  // 0: GTCNT counts down.
	  // 1: GTCNT counts up.
	GPT3.GTUDC.BIT.UDF = 0;
	  // 0: Not forcibly set
	  // 1: Forcibly set

	/*General PWM Timer I/O Control Register (GTIOR)*/
	GPT3.GTIOR.BIT.GTIOA = 0x07;  //PWMNH //010 //0x000111: Compare match(b5), Initial output is low(b4), Low output at cycle end(b3, b2), Toggle output at GPTn.GTCCRA compare match
	GPT3.GTIOR.BIT.GTIOB = 0x1B;  //PWMNL //101 //0x011011: Compare match(b5), Initial output is high(b4), High output at cycle end(b3, b2), Toggle output at GPTn.GTCCRA compare match

	/*General PWM Timer Buffer Enable Register (GTBER)*/
	GPT3.GTBER.BIT.CCRA = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTCCRA <=> GTCCRC)
	  // 1x: Double buffer operation (GTCCRA <=> GTCCRC <=> GTCCRD)
	GPT3.GTBER.BIT.CCRB = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTCCRB <=> GTCCRE)
	  // 1x: Double buffer operation (GTCCRB <=> GTCCRE <=> GTCCRF)
	GPT3.GTBER.BIT.PR = 1;
	  // 00: Buffer operation is not performed
	  // 01: Single buffer operation (GTPBR <=> GTPR)
	  // 1x: Double buffer operation (GTPDBR <=> GTPBR <=> GTPR)

	/*General PWM Timer Cycle Setting Register (GTPR)*/
	GPT3.GTPR = 3030;   //19.8 kHz
	GPT3.GTPBR = 3030; //19.8 kHz

	/*General PWM timer Compare Capture Register m (GTCCRm)*/
	//GPT3.GTCCRA = 300;
	//GPT3.GTCCRB = 270;

	/*General PWM Timer Output Negate Cintrol Register(GTONCR)*/
	// GRIOCnA Pin Negate Control Enable
	GPT3.GTONCR.BIT.NEA = 0;  // 0: Negate is disabled
	GPT3.GTONCR.BIT.NEB = 0;  // 1: Negate is enabled
	GPT3.GTONCR.BIT.NVA = 0;  // 0: No pin output
	GPT3.GTONCR.BIT.NVB = 0;  // 1: Pin output
	// GRIOCnA Pin Output Enable
	GPT3.GTONCR.BIT.OAE = 0;  // 0: Output is disabled
	GPT3.GTONCR.BIT.OBE = 0;  // 1: Output is enabled

    
    /*set A/D buffer register*/
     GPT3.GTBER.BIT.ADTTA = 1;
          // Triangle waves
          // 00: No transfer
          // 01: Transfer at crest
          // 10: Transfer at trough
          // 11: Transfer at both crest and trough
     GPT3.GTBER.BIT.ADTDA = 0;
          // 0: Single buffer operation(GTADTBRA -> GTADTRA)
          // 1: Double buffer operation(GTADTDBRA -> GTADTBRA -> GTADTRA)
     GPT3.GTBER.BIT.ADTTB = 1;
          // Triangle waves
          // 00: No transfer
          // 01: Transfer at crest
          // 10: Transfer at trough
          // 11: Transfer at both crest and trough
     GPT3.GTBER.BIT.ADTDB = 0;
          // 0: Single buffer operation(GTADTBRB -> GTADTRB)
          // 1: Double buffer operation(GTADTDBRB -> GTADTBRB -> GTADTRB)
	
    /*Setting A/D converter Start Request Enable*/
    GPT3.GTINTAD.BIT.ADTRAUEN = 0;
    GPT3.GTINTAD.BIT.ADTRADEN = 1; //Enable GTADTRA Compare Match (DownCounting) A/D Converter Start
    GPT3.GTINTAD.BIT.ADTRBUEN = 0;
    GPT3.GTINTAD.BIT.ADTRBDEN = 0;

    /*Setting A/D Trigger timer*/
	GPT3.GTADTRA =2898;    // sams as GPT3.GTCCRD (Cycle_sign Interrupt) designed by sampling frequency
	GPT3.GTADTBRA = 2898;


    GPT3.GTINTAD.BIT.GTINTPR = 0;
	  //00:Interrupt request is disabled.
	  //01:In saw-wave mode, interrupt requests are enabled at overflows.
	  //   In triangle-wave mode, interrupt requests are enabled at crests.
	  //10:In saw-wave mode, interrupt requests are enabled at underflows.
	  //   In triangle-wave mode, interrupt requests are enabled at troughs.
	  //11:In saw-wave mode, interrupt requests are enabled at both overflows and underflows. 
	  //   In triangle-wave mode, interrupt requests are enabled at both crests and troughs.

    // Cycle_sign Interrupt trigger source 
    GPT3.GTCCRD =2898;                   
    GPT3.GTINTAD.BIT.GTINTD = 1; //enable GTCCRD interrupt (GTCID3)
    
    IEN(PERIA, INTA210) = 0;
    ICU.SLIAR210.BYTE = 0x4F;      //Interrupt source NO=79 (GTCID3)
    IPR(PERIA, INTA210) = 11;
    IR(PERIA, INTA210) = 0;
    IEN(PERIA, INTA210) = 1;                   
    
    
}

void init_AD12A(void){
	/*Cancel S12AD & S12AD1 module stop state*/
	MSTP(S12AD) = 0;
	MSTP(S12AD1) = 0;

	/*Set S12AD & S12AD1 control registers*/
	S12AD.ADCSR.BIT.ADST = 0;
	  // 0: Stops A/D conversion process.
	  // 1: Starts A/D conversion process.
	S12AD.ADCSR.BIT.EXTRG = 0;
	  // 0: A/D conversion is started by a synchronous trigger (MTU, GPT, TPU, TMR, ELC).
	  // 1: A/D conversion is started by the asynchronous trigger (ADTRG0# in unit 0; ADTRG1# in unit 1).
	S12AD.ADCSR.BIT.TRGE = 1;
	  // 0: Disables A/D conversion to be started by the synchronous or asynchronous trigger.
	  // 1: Enables A/D conversion to be started by the synchronous or asynchronous trigger.
	S12AD.ADCSR.BIT.ADIE = 1; //after A/D conversion,enter to interrupt
	  // 0: Disables S12ADI interrupt generation upon scan completion.
	  // 1: Enables S12ADI interrupt generation upon scan completion.
	S12AD.ADCSR.BIT.ADCS = 0;
	  // 00: Single scan mode
	  // 01: Group scan mode
	  // 10: Continuous scan mode
	  // 11: Setting prohibited

	// S12AD1
	S12AD1.ADCSR.BIT.ADST = 0;
	  // 0: Stops A/D conversion process.
	  // 1: Starts A/D conversion process.
	S12AD1.ADCSR.BIT.EXTRG = 0;
	  // 0: A/D conversion is started by a synchronous trigger (MTU, GPT, TPU, TMR, ELC).
	  // 1: A/D conversion is started by the asynchronous trigger (ADTRG0# in unit 0; ADTRG1# in unit 1).
	S12AD1.ADCSR.BIT.TRGE = 1;
	  // 0: Disables A/D conversion to be started by the synchronous or asynchronous trigger.
	  // 1: Enables A/D conversion to be started by the synchronous or asynchronous trigger.
	S12AD1.ADCSR.BIT.ADIE = 1; //after A/D conversion,enter to interrupt
	  // 0: Disables S12ADI interrupt generation upon scan completion.
	  // 1: Enables S12ADI interrupt generation upon scan completion.
	S12AD1.ADCSR.BIT.ADCS = 0;
	  // 00: Single scan mode
	  // 01: Group scan mode
	  // 10: Continuous scan mode
	  // 11: Setting prohibited

	/*A/D Control Extended Register (ADCER)*/
	S12AD.ADCER.WORD = 0x0000;
	S12AD1.ADCER.WORD = 0x0000;
	
	/*Set S12AD smaple and hold control registers*/
	S12AD.ADSHCR.BIT.SHANS = 7;
	  //select AN000 to AN002 pins

	/* Set channels */
	S12AD.ADANSA0.WORD = 0x00FF;   //AN000 to AN007
	S12AD1.ADANSA0.WORD = 0x8FC7; //AN000 to AN002(igx) add HVDC //01-Nov-2019 22:16:19
    //If control principle change, the channel might be changed 
     
	/*Set AD conversion start trigger sources*/
	S12AD.ADSTRGR.WORD = 0x1700;  //we choose 19.8KHz(sample frequency)
    // S12AD compare with GPT3.GTADTRA switching cycle =19.8KHz

    S12AD1.ADSTRGR.WORD = 0x1700;  // S12AD1 compare with GPT3.GTADTRA

	/*Set interrupt and priority level*/
	//S12AD
	IEN(PERIB, INTB128) = 0;
	ICU.SLIBXR128.BYTE = 0x40;
	IPR(PERIB, INTB128) = 10;
	IR(PERIB, INTB128) = 0;

	//S12AD1
	IEN(PERIB, INTB129) = 0;
	ICU.SLIBXR129.BYTE = 0x44;
	IPR(PERIB, INTB129) = 9;
	IR(PERIB, INTB129) = 0;
	
}

